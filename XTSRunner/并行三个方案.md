# 优化并行处理方案

我可以将方案改为按仓库类型分组，将库分为三类：openharmony-sig、openharmony-tpc 和 openharmony_tpc_samples。这样可以更有效地并行处理不同类型的仓库。

以下是修改后的方案：

```python:d:\code\JavaProject\XTSRunner\config.py
# 三套配置
# 第一套配置 - openharmony-sig
BUNDLE_NAME_SIG = "cn.openharmony.sig"
SIGNING_CONFIG_SIG = {
    "name": "default_sig",
    "type": "HarmonyOS",
    "material": {
        "certpath": "C:\\Users\\admin\\.ohos\\config\\default_sig_cert.cer",
        # ... 其他签名配置
    }
}

# 第二套配置 - openharmony-tpc
BUNDLE_NAME_TPC = "cn.openharmony.tpc"
SIGNING_CONFIG_TPC = {
    "name": "default_tpc",
    "type": "HarmonyOS",
    "material": {
        "certpath": "C:\\Users\\admin\\.ohos\\config\\default_tpc_cert.cer",
        # ... 其他签名配置
    }
}

# 第三套配置 - openharmony_tpc_samples
BUNDLE_NAME_SAMPLES = "cn.openharmony.samples"
SIGNING_CONFIG_SAMPLES = {
    "name": "default_samples",
    "type": "HarmonyOS",
    "material": {
        "certpath": "C:\\Users\\admin\\.ohos\\config\\default_samples_cert.cer",
        # ... 其他签名配置
    }
}

# 默认配置（向后兼容）
BUNDLE_NAME = BUNDLE_NAME_TPC
SIGNING_CONFIG = SIGNING_CONFIG_TPC
```

```python:d:\code\JavaProject\XTSRunner\main.py
def run_libraries_part(libraries, urls, repo_type, bundle_name, signing_config):
    """运行指定仓库类型的库"""
    # 复制一份全局配置
    import copy
    import sys
    from config import BUNDLE_NAME, SIGNING_CONFIG
    
    # 临时修改配置
    original_bundle = BUNDLE_NAME
    original_signing = copy.deepcopy(SIGNING_CONFIG)
    
    # 使用传入的配置
    globals()['BUNDLE_NAME'] = bundle_name
    globals()['SIGNING_CONFIG'] = signing_config
    
    try:
        # 设置进程标识，用于日志区分
        print(f"==================================================")
        print(f"开始执行 {repo_type} 仓库测试，共 {len(libraries)} 个库")
        print(f"==================================================")
        
        # 创建该仓库类型的专用报告目录
        report_dir = os.path.join(REPORT_DIR, repo_type)
        os.makedirs(report_dir, exist_ok=True)
        
        # 运行库的逻辑（基于原有run_all_libraries代码）
        overall_results = {
            "total": 0,
            "passed": 0,
            "failed": 0,
            "total_libs": len(libraries),
            "passed_libs": 0,
            "failed_libs": 0,
            "libraries": []
        }
        
        # 执行每个库的测试
        for idx, library_name in enumerate(libraries, 1):
            try:
                print(f"==================================================")
                print(f"开始执行 {repo_type} 仓库的第 {idx}/{len(libraries)} 个库: {library_name}")
                print(f"==================================================")
                
                # 这里调用原有的测试逻辑
                # ...原有代码...
                
            except Exception as e:
                print(f"执行库 {library_name} 时出错: {str(e)}")
                # 错误处理逻辑
                # ...原有代码...
        
        # 生成该仓库类型的报告
        generate_final_report(overall_results, os.path.join(report_dir, f"{repo_type}_report.html"))
        
        return overall_results
    finally:
        # 恢复原始配置
        globals()['BUNDLE_NAME'] = original_bundle
        globals()['SIGNING_CONFIG'] = original_signing

def classify_libraries(libraries, urls):
    """根据URL将库分类为三种仓库类型"""
    sig_libs = []
    tpc_libs = []
    samples_libs = []
    
    for lib in libraries:
        url = urls.get(lib, "")
        if not url:
            continue
            
        if "openharmony-sig" in url:
            sig_libs.append(lib)
        elif "openharmony_tpc_samples" in url:
            samples_libs.append(lib)
        elif "openharmony-tpc" in url:
            tpc_libs.append(lib)
        else:
            # 默认归类为tpc
            tpc_libs.append(lib)
    
    return sig_libs, tpc_libs, samples_libs

if __name__ == "__main__":
    # 读取Excel获取所有库
    from config import BUNDLE_NAME_SIG, SIGNING_CONFIG_SIG
    from config import BUNDLE_NAME_TPC, SIGNING_CONFIG_TPC
    from config import BUNDLE_NAME_SAMPLES, SIGNING_CONFIG_SAMPLES
    
    libraries, _, urls = read_libraries_from_excel()
    
    # 按仓库类型分类
    sig_libs, tpc_libs, samples_libs = classify_libraries(libraries, urls)
    
    print(f"库分类结果:")
    print(f"- openharmony-sig: {len(sig_libs)} 个库")
    print(f"- openharmony-tpc: {len(tpc_libs)} 个库")
    print(f"- openharmony_tpc_samples: {len(samples_libs)} 个库")
    
    # 启动三个进程
    import multiprocessing
    
    # 进程1 - openharmony-sig
    p1 = multiprocessing.Process(
        target=run_libraries_part,
        args=(sig_libs, urls, "openharmony-sig", 
              BUNDLE_NAME_SIG, 
              SIGNING_CONFIG_SIG)
    )
    
    # 进程2 - openharmony-tpc
    p2 = multiprocessing.Process(
        target=run_libraries_part,
        args=(tpc_libs, urls, "openharmony-tpc",
              BUNDLE_NAME_TPC,
              SIGNING_CONFIG_TPC)
    )
    
    # 进程3 - openharmony_tpc_samples
    p3 = multiprocessing.Process(
        target=run_libraries_part,
        args=(samples_libs, urls, "openharmony_tpc_samples",
              BUNDLE_NAME_SAMPLES,
              SIGNING_CONFIG_SAMPLES)
    )
    
    # 启动所有进程
    p1.start()
    p2.start()
    p3.start()
    
    # 等待所有进程完成
    p1.join()
    p2.join()
    p3.join()
    
    # 合并报告
    print("所有测试完成，开始合并报告...")
    # 这里添加合并三个报告的逻辑
```

```python:d:\code\JavaProject\XTSRunner\ModfyConfig.py
def _update_config():
    """更新build-profile.json5文件中的签名配置"""
    # 动态导入当前进程使用的签名配置
    import sys
    current_module = sys.modules[__name__]
    
    # 获取全局SIGNING_CONFIG
    if hasattr(current_module, 'SIGNING_CONFIG'):
        new_signing_config = current_module.SIGNING_CONFIG
    else:
        from config import SIGNING_CONFIG
        new_signing_config = SIGNING_CONFIG
    
    # ... 其余代码保持不变
```

这个优化方案的主要改进点：

1. **按仓库类型分组**：将库分为三类 - openharmony-sig、openharmony-tpc 和 openharmony_tpc_samples
2. **独立配置**：每种仓库类型使用独立的bundle_name和签名配置
3. **独立报告目录**：每种仓库类型生成独立的报告，便于分析
4. **动态配置**：ModfyConfig.py中动态获取当前进程的签名配置

这种方案的优势：
- 更精细的并行控制
- 按仓库类型分组更有意义，可能有相似的构建特性
- 便于针对不同类型仓库进行优化
- 报告更有组织性

需要注意的事项：
1. 确保三套签名配置都是有效的
2. 可能需要调整classify_libraries函数的分类逻辑，以适应实际URL格式
3. 考虑添加进度监控和错误恢复机制