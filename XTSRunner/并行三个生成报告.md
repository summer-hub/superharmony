# 修改报告生成系统以支持三个并行进程

我将修改报告生成系统，使其支持三个并行进程分别处理不同类型的仓库。主要需要修改以下几个方面：

1. 为每个进程创建独立的报告目录
2. 确保报告文件名不冲突
3. 添加仓库类型标识到报告中

## 1. 修改 GenerateTestReport.py

```python:d:\code\JavaProject\XTSRunner\GenerateTestReport.py
def save_test_json(test_results, summary, class_times, component_name, repo_type=None):
    """
    将测试结果保存为JSON文件
    
    参数:
        test_results: 测试结果字典
        summary: 测试摘要信息
        class_times: 测试类耗时字典
        component_name: 组件名称
        repo_type: 仓库类型，用于区分不同进程的报告
    """
    # 创建TestJson目录（如果不存在）
    test_json_dir = os.path.join(os.getcwd(), "TestJson")
    if repo_type:
        test_json_dir = os.path.join(test_json_dir, repo_type)
    
    if not os.path.exists(test_json_dir):
        os.makedirs(test_json_dir)
    
    # 创建一个包含所有信息的字典
    data = {
        "summary": summary,
        "class_times": class_times,
        "test_results": test_results,
        "total_time_ms": summary.get('total_time_ms', 0),
        "repo_type": repo_type  # 添加仓库类型信息
    }
    
    # 生成JSON文件名
    output_file = os.path.join(test_json_dir, f"{component_name}_results.json")
    
    # 保存为JSON文件
    with open(output_file, "w", encoding="utf-8") as f:
        json.dump(data, f, indent=2, ensure_ascii=False)
    
    print(f"测试结果已保存到 {output_file}")

# ... 其他代码保持不变 ...

def generate_test_report(test_names, output, original_name, repo_type=None):
    """生成HTML格式的测试报告"""
    # ... 现有代码保持不变 ...
    
    # 保存测试结果为JSON
    save_test_json(test_results, summary, class_times, component_name, repo_type)
    
    # 更新Excel中的测试结果
    update_excel_result(summary, component_name)

    # ... 现有代码保持不变 ...

    # 确保报告目录存在
    report_dir = REPORT_DIR
    if repo_type:
        report_dir = os.path.join(REPORT_DIR, repo_type)
    
    if not os.path.exists(report_dir):
        os.makedirs(report_dir)

    # 使用原始组件名生成报告文件
    report_path = os.path.join(report_dir, f"{original_name}.html")
    with open(report_path, "w", encoding="utf-8") as f:
        f.write(html_content)

    print(f"\n测试报告已生成: {report_path}")
```

## 2. 修改 GenerateHtmlReport.py

```python:d:\code\JavaProject\XTSRunner\GenerateHtmlReport.py
def update_overall_results(overall_results, repo_type=None):
    """更新总体结果文件"""
    try:
        # 确保报告目录存在
        html_report_dir = os.path.join(PROJECT_DIR, "html-report")
        if repo_type:
            html_report_dir = os.path.join(html_report_dir, repo_type)
            
        if not os.path.exists(html_report_dir):
            os.makedirs(html_report_dir)
        
        # 保存总体结果到JSON文件
        results_file = os.path.join(html_report_dir, "overall_results.json")
        with open(results_file, 'w', encoding='utf-8') as f:
            json.dump(overall_results, f, ensure_ascii=False, indent=2)
            
    except Exception as e:
        print(f"更新总体结果文件时出错: {str(e)}")

def generate_html_report(overall_results, repo_type=None):
    """生成详细的HTML测试报告"""
    try:
        print(f"生成{repo_type or ''}详细HTML测试报告...")

        # 创建报告目录
        html_report_dir = os.path.join(PROJECT_DIR, "html-report")
        if repo_type:
            html_report_dir = os.path.join(html_report_dir, repo_type)
            
        if not os.path.exists(html_report_dir):
            os.makedirs(html_report_dir)
        
        # ... 其他代码保持不变 ...
        
        # 生成总体报告
        main_report_path = generate_main_report(overall_results, repo_groups, current_time, html_report_dir, repo_type)
        
        print(f"HTML报告已生成: {main_report_path}")
        return main_report_path
        
    except Exception as e:
        print(f"生成HTML报告时出错: {str(e)}")
        import traceback
        traceback.print_exc()
        return None

def generate_main_report(overall_results, repo_groups, current_time, html_report_dir, repo_type=None):
    """生成主报告页面"""
    # ... 现有代码保持不变 ...
    
    # 添加仓库类型到标题
    repo_type_title = f" - {repo_type}" if repo_type else ""
    
    # 修改HTML模板，添加仓库类型到标题
    html_template = """<!DOCTYPE html>
    <html>
    <head>
        <title>测试报告总览{repo_type_title}</title>
        <!-- ... 其他HTML内容 ... -->
    </head>
    <body>
        <div class="header">
            <h1>测试报告总览{repo_type_title}</h1>
            <!-- ... 其他HTML内容 ... -->
        </div>
        <!-- ... 其他HTML内容 ... -->
    </body>
    </html>
    """
    
    # ... 其他代码保持不变 ...
```

## 3. 修改 GenerateAllureReport.py

```python:d:\code\JavaProject\XTSRunner\GenerateAllureReport.py
def generate_allure_report(test_results, library_name, repo_type=None):
    """生成Allure格式的测试报告"""
    try:
        # 确保allure-results目录存在
        allure_dir = ALLURE_RESULTS_DIR
        if repo_type:
            allure_dir = os.path.join(ALLURE_RESULTS_DIR, repo_type)
            
        os.makedirs(allure_dir, exist_ok=True)
        
        # ... 其他代码保持不变 ...
        
        # 写入Allure结果文件
        result_file = os.path.join(allure_dir, f"{lib}_{test_class}_{test_name}-result.json")
        with open(result_file, 'w', encoding='utf-8') as f:
            json.dump(allure_result, f, ensure_ascii=False)
                    
        # ... 其他代码保持不变 ...
```

## 4. 修改 ReportGenerator.py

```python:d:\code\JavaProject\XTSRunner\ReportGenerator.py
def generate_reports(test_names, output, original_name, repo_type=None):
    """
    生成测试报告并更新总体测试结果
    
    该函数为单个库生成测试报告,并将结果整合到总体测试结果中。主要功能包括:
    - 解析测试结果数据
    - 生成HTML格式的详细测试报告
    - 生成Allure测试报告
    - 更新总体测试结果统计
    - 保存库的详细测试信息
    
    参数:
        test_names: 测试用例名称列表
        output: 测试输出结果
        original_name: 被测试库的名称
        repo_type: 仓库类型，用于区分不同进程的报告
    """
    try:
        global all_libraries_results
        
        # ... 其他代码保持不变 ...
        
        try:
            # 生成HTML详细报告
            generate_test_report(test_names, output, original_name, repo_type)
        except Exception as html_err:
            print(f"生成HTML报告时出错: {str(html_err)}")
        
        try:
            # 生成Allure报告
            generate_allure_report(test_results, original_name, repo_type)
        except Exception as allure_err:
            print(f"生成Allure报告时出错: {str(allure_err)}")
        
        # ... 其他代码保持不变 ...
        
        # 更新总体结果文件（但不生成最终报告）
        update_overall_results(all_libraries_results, repo_type)
        
        # ... 其他代码保持不变 ...
        
    except Exception as e:
        print(f"生成报告时出错: {str(e)}")
        import traceback
        traceback.print_exc()

def generate_final_report(overall_results, output_path=None, repo_type=None):
    """生成最终的总体报告"""
    try:
        # 生成HTML总体报告
        html_report_path = generate_html_report(overall_results, repo_type)
        
        # ... 其他代码保持不变 ...
        
    except Exception as e:
        print(f"生成最终报告时出错: {str(e)}")
        import traceback
        traceback.print_exc()
```

## 5. 修改 main.py 中的报告调用

```python:d:\code\JavaProject\XTSRunner\main.py
def run_libraries_part(libraries, urls, repo_type, bundle_name, signing_config):
    """运行指定仓库类型的库"""
    # ... 其他代码保持不变 ...
    
    try:
        # ... 其他代码保持不变 ...
        
        # 执行每个库的测试
        for idx, library_name in enumerate(libraries, 1):
            try:
                # ... 其他代码保持不变 ...
                
                # 生成报告时传入repo_type
                from ReportGenerator import generate_reports
                generate_reports([name], output, library_name, repo_type)
                
                # ... 其他代码保持不变 ...
                
            except Exception as e:
                # ... 其他代码保持不变 ...
        
        # 生成该仓库类型的最终报告
        from ReportGenerator import generate_final_report
        generate_final_report(overall_results, None, repo_type)
        
        return overall_results
    finally:
        # ... 其他代码保持不变 ...
```

## 总结

这些修改将使报告系统能够支持三个并行进程，每个进程处理不同类型的仓库：

1. 每个进程有独立的报告目录，按仓库类型分类
2. 报告文件名包含仓库类型，避免冲突
3. 报告内容中添加了仓库类型标识
4. 每个进程独立生成总体报告

这样，三个并行进程可以同时运行而不会相互干扰，每个进程的报告都会保存在对应的目录中。最终，你可以查看三个不同的总体报告，分别对应三种不同类型的仓库。